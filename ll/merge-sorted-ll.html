<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/utils.css">
    <link rel="stylesheet" href="../css/style.css"> 
    <link rel="stylesheet" href="../css/topic.css"> 
    <link rel="stylesheet" href="../css/post.css"> 
    <link rel="stylesheet" href="../css/mobile.css">

    <title>codessy</title>
</head>
<body>
    <nav class="navigation max-width-1 m-auto ">
        <div class="nav-left">
            <a href="/"><img src="img/logo.png" alt="logo"></a>
            <ul>
                <li><a href="/">Home üè†</a></li>
                <li><a href="/topics.html">Topics üìö</a></li>
                <li><a href="/about.html">About üòá</a></li>
                <li><a href="/contact.html">Contact üì©</a></li>
            </ul>
        </div>
        <div class="nav-right">
            <form action="/search.html" data-netlify="true">
                <input class="form-input" type="text" placeholder="Search Topics">
                <button class="btn">Search</button>
            </form>
        </div>
    </nav>
    <hr class="postart max-width-1 m-auto">
    <div class="array-articles font1">
        <div class="notes">
            <h1>Merge Two Sorted Linked List üîó</h1>
            <p>Given a Linked List, detect if there is any loop present in the linked list :)</p>
            <p>Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. <br> <br>
                For example, if the input were given that head = [1, 3, 2, 5] and pos = 1, the linked list would look like this:
                </p>
<img src="img/ll1.png" alt="example" >
            <textarea name="" id="" cols="15" rows="5">
</textarea>
            <a href="https://practice.geeksforgeeks.org/problems/make-matrix-beautiful-1587115620/1/"><button class="btn">Give it a try :)</button></a>
            <h3>Approach 1 (Hash Map)</h3>
<p>One way to detect the loop can be using map. We can store the count of the nodes appearing, in our linked list. If we encounter any node twice, then its frequency will be increased by 1, i.e. it will become 2.</p>

<b>Algorithm:</b> <br>
1. We will declare three pointers, namely *curr, *prev and *nex, where *curr will help us in traversing through the linked list. <br><br>
2. While *prev will keep a track of previous of the current and *nex will keep a track of the next pointer of the *curr.<br><br>
3. Point *nex to the curr->next as we will be breaking the link from the *curr pointer onwards.<br><br>
4. Now break the link and point curr->next to the previous pointer i.e. *prev.<br><br>
5. Now we will simply move forward *curr and *prev.<br><br>
6. Repeat steps 3-6 till current does NOT become equal to NULL. <br><br>
Happy Coding :)<br></p>
           
	<h3>CODE:</h3>
            <textarea name="" id="" cols="30" rows="20">
bool detectLoop(Node* head)
{
    Node *t1=head;
    unordered_map<int,int> mp;
    while(t1){
        t1=t1->next;
        mp[t1->data]++;
        if(mp[t1->data]>1)
            return true;
    }
    return false;
}               

            </textarea>
            <h3>Complexities: </h3>
            <p><em>Time Complexity: </em> O(n)
            <br>
            <em>Space Complexity: </em> O(n)</p>
            <h3>Approach 2 (Hareü¶å and Tortoiseüê¢ Algorithm)</h3>
<p>The idea behind the algorithm is that, if you have two pointers in a linked list, one moving twice as fast (the hare) than the other (the tortoise), then if they intersect, there is a cycle in the linked list. If they don't intersect, then there is no cycle.</p>

   <p> <b>Intuition:-</b> If there is no loop in the linked list, then the two pointers will never meet, while if there is a loop in the linked list then they would surely meet. As the hare is moving twice as fast as the tortoise.</p>
    
    <b>Why the collision is must to happen?</b> <br>
    
    Imagine there is a tunnel which has a cycle, i.e. a tunnel in the shape of 9. <br> <br>
    
    <p>If we start traversing in such a tunnel, we would be stuck forever, and would never come to an end. But is there any way we could detect if there is a cycle in the tunnel??
    Yess! Indeed. Let us send two friends inside the tunnel Sodhi and Bhide, now Sodhi being enthusiastic, walks much faster as compared to Bhide. Now if they start traversing the tunnel at the same point of time. They will meet for sure. Why?? ü§î <br><br>
    
    One answer could be relative speed for sure. If we stop Bhide using the concept of relative speed, Sodhi will still be moving, since he is moving at comparatively faster speed. Thus the collision is must to happen in case of hare and tortoise as well :)</p>

<b>Algorithm:</b> <br>
1. The first thing I'll do is check if head exists, and if head.next exists. If neither exist, then there is no cycle, and I'll immediately return false.<br><br>

2. Next, I'll initiate a slow and fast pointer. The slow pointer, tortoise, will start at the head node. The fast pointer, hare, will start one step ahead, at head.next.<br><br>

3. Now, as long as the hare is still pointing at a node that isn't null, and the next node still isn't null, we will continue checking things.<br><br> 

4. Inside the while loop, the first thing to do is to check if the tortoise and hare are pointing to the same node. If they are, that means it's a cycle, so we can return true.<br><br>

5. Otherwise, we will move the tortoise and hare. The tortoise moves one node at a time, and the hare moves two nodes at a time.<br><br>

Finally, if the while loop cannot continue because hare and/or hare.next is null, then that means no cycle was ever found, so we can return false. :)<br></p>
           
	<h3>CODE:</h3>
            <textarea name="" id="" cols="30" rows="20">
bool detectLoop(Node* head){
    Node *slow = head;
    Node *fast = head;
    while(slow && fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(slow==fast)
            return true;
    }
    return false;
}
            </textarea>
            <h3>Complexities: </h3>
            <p><em>Time Complexity: </em> O(n)
            <br>
            <em>Space Complexity: </em> O(n)</p>
            
        </div>
    </div>
    <div class="home-articles  font1">
        <h1>People who read this also read!</h1>
        <div class="top-row">
            <div class="box">
                <a href="/array.html">
                    <img src="../img/array.png" alt="driving license" class="center">
                    Arrays
                </a>
            </div>
            <div class="box">
                <a href="/string.html">
                    <img src="../img/code2.png" alt="driving license" class="center">
                    String
                </a>
            </div>
            <div class="box">
                <a href="/greedy.html">
                    <img src="../img/code1.png" alt="driving license" class="center">
                    Greedy
                </a>
            </div>
        </div>
    </div>
    <hr class="postart max-width-1 m-auto">
    <div class="footer max-width-1 m-auto">
        Copyright &copy; codessy.com
    </div>
</body>
</html>